#' Simulate tau-leaped trajectories from n-strain stochastic SIS
#' @param t0 start time
#' @param tmax end time
#' @param nstep number of tau-leaped steps
#' @param n_strains number of strains to simulate
#' @param S_0 initial susceptible population
#' @param I_0 initial infected populations, 1 per strain
#' @param usage_func abx of interest usage function
#' @param beta_func force of infection function
#' @param N_func population size function
#' @param gamma_u recovery rates when not treated with ABX of interest
#' @param gamma_t recovery rates when treated with ABX of interest
#' @export 
simulate_epi_nstrain <- function(t0, tmax, nstep, n_strains, S_0, I_0, usage_func, beta_func, N_func, gamma_u, gamma_t) {
    times <- seq(from=t0,to=tmax, length.out=nstep)
    usage_data <- sapply(times, usage_func)
    beta_data <- sapply(times, beta_func)
    N_data <- sapply(times, N_func)
    dt <- times[2]-times[1]

    DF_out <- simulate_fast_nstrain(
        n_strains,
        I_0,
        S_0,
        usage_data,
        beta_data,
        N_data,
        gamma_u,
        gamma_t,
        times,
        dt)
    return(DF_out)
}

#' Simulate coalescent trees based on supplied trajectory
#' @param DF_in Simulated trajectory generated by simulate_epi
#' @param samp_times Sampling times given as a time before present measured from simulation end point
#' @param n_samp number of samples taken at each sampling time
#' @export
simulate_phylos_nstrain <- function(DF_in, strain_idx, samp_times, n_samp) {
    phys <- list()

    stopifnot(length(n_samp)==length(strain_idx))
    stopifnot(length(samp_times)==length(strain_idx))

    for (i in c(1:length(strain_idx))) {
        j <- strain_idx[i]
        DF_s <- DF_in[,c(paste0("I_", j), "inf_rate", "t")]
        colnames(DF_s) <- c("I", "inf_rate", "t")
        phy <- simulate_coal_times2(DF_s, samp_times[[i]], n_samp[[i]])
        phys[[i]] <- build_coal_tree(phy$samp_times, phy$n_samp, phy$coal_times)
    }

    return(phys)
}

#' Simulate coalescent trees based on supplied trajectory
#' @param DF_in Simulated trajectory generated by simulate_epi
#' @param samp_times Sampling times given as a time before present measured from simulation end point
#' @param n_samp number of samples taken at each sampling time
#' @export
simulate_phylos <- function(DF_in, samp_times, n_samp) {
    phys <- simulate_coal_times(DF_in, samp_times, n_samp)

    p_sus <- phys$phy_s
    p_res <- phys$phy_r

    phy_sus <- build_coal_tree(p_sus$samp_times, p_sus$n_samp, p_sus$coal_times)
    phy_res <- build_coal_tree(p_res$samp_times, p_res$n_samp, p_res$coal_times)
    return(list(phy_sus=phy_sus, phy_res=phy_res))
}

#' Simulate coalescent process event times based on supplied trajectory
#' @param DF_in Dataframe with columns: I - the trajectory, inf_rate - the per capita infection rate, t - time
#' @param samp_times Sampling times given as a time before present measured from simulation end point
#' @param n_samp number of samples taken at each sampling time
#' @export
simulate_coal_times2 <- function(DF_in, samp_times, n_samp) {
    t_min <- min(DF_in$t)
    t_max <- max(DF_in$t)

    stopifnot(length(samp_times) == length(n_samp))

    stopifnot(samp_times>=0)
    stopifnot(samp_times<=(t_max-t_min))
    stopifnot(n_samp>0)

    eval_times <- DF_in$t 
    dt <- eval_times[2]-eval_times[1]

    Neg <- sapply((1:length(eval_times)), function(i) (DF_in$I[i])/(2*DF_in$inf_rate[i]))

    stopifnot(all(Neg>0))
    phy <- sim_coal(samp_times, n_samp, Neg, eval_times)

    return(phy)
}


#' Simulate coalescent process event times based on supplied trajectory
#' @param DF_in Simulated trajectory generated by simulate_epi
#' @param samp_times Sampling times given as a time before present measured from simulation end point
#' @param n_samp number of samples taken at each sampling time
#' @export
simulate_coal_times <- function(DF_in, samp_times, n_samp) {
    t_min <- min(DF_in$t)
    t_max <- max(DF_in$t)

    stopifnot(length(samp_times$sus) == length(n_samp$sus))
    stopifnot(length(samp_times$res) == length(n_samp$res))

    stopifnot(samp_times$sus>=0)
    stopifnot(samp_times$sus<=(t_max-t_min))
    stopifnot(samp_times$res>=0)
    stopifnot(samp_times$res<=(t_max-t_min))
    stopifnot(n_samp$sus >0)
    stopifnot(n_samp$res >0)


    eval_times <- DF_in$t 
    dt <- eval_times[2]-eval_times[1]

    Neg_s <- sapply((1:length(eval_times)), function(i) (DF_in$I_s[i])/(2*DF_in$inf_rate[i]))
    Neg_r <- sapply((1:length(eval_times)), function(i) (DF_in$I_r[i])/(2*DF_in$inf_rate[i]))

    stopifnot(all(Neg_s>0))
    stopifnot(all(Neg_r>0))
    phy_s <- sim_coal(samp_times$sus, n_samp$sus, Neg_s, eval_times)
    phy_r <- sim_coal(samp_times$res, n_samp$res, Neg_r, eval_times)

    #phy_s <- coalsim(samp_times$sus, n_samp$sus, rev_time_step_func(Neg_s, t_min, t_max, dt), method="thin", lower_bound = min(Neg_s))
    #phy_r <- coalsim(samp_times$res, n_samp$res, rev_time_step_func(Neg_r, t_min, t_max, dt), method="thin", lower_bound = min(Neg_r))

    return(list(phy_s=phy_s, phy_r=phy_r))
}

#Backwards time step function relative to t_max
#Arr should be in natural (forwards) time
rev_time_step_func <- function(arr, t_min, t_max, dt) {
    upper <- t_max-t_min
    n <- length(arr)
    stopifnot("t_max must be greater than t_min"=(upper > 0))
    stopifnot(abs(upper/dt+1-n) < 1e-6) 
    func_out <- function(t) {
        if(t >= 0 && t < upper) {
            index <- n-floor(t/dt)
            stopifnot(index >= 1)
            stopifnot(index <= n)
            out <- arr[index]
        } else {
            out <- min(arr)
        }
        return(out)
    }
    return(func_out)
}

